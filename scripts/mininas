#!/usr/bin/env node

const path = require("node:path");
const fs = require("node:fs");
const crypto = require("node:crypto");

// Load .env from monorepo root
const envPath = path.resolve(__dirname, "../.env");
if (fs.existsSync(envPath)) {
  for (const line of fs.readFileSync(envPath, "utf-8").split("\n")) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith("#")) continue;
    const eq = trimmed.indexOf("=");
    if (eq === -1) continue;
    const key = trimmed.slice(0, eq);
    const value = trimmed.slice(eq + 1);
    if (!(key in process.env)) process.env[key] = value;
  }
}

const { createRequire } = require("node:module");
const apiRequire = createRequire(
  path.resolve(__dirname, "../packages/api/package.json")
);
const Database = apiRequire("better-sqlite3");

// Resolve DB path relative to packages/api/ (where the server runs from)
const apiDir = path.resolve(__dirname, "../packages/api");
const dbPath = path.resolve(
  apiDir,
  process.env.DB_PATH || "./data/mininas.db"
);

function getDb() {
  const dbDir = path.dirname(dbPath);
  fs.mkdirSync(dbDir, { recursive: true });
  const db = new Database(dbPath);
  db.pragma("journal_mode = WAL");
  db.pragma("foreign_keys = ON");
  db.exec(`
    CREATE TABLE IF NOT EXISTS volumes (
      id TEXT PRIMARY KEY,
      label TEXT NOT NULL,
      path TEXT NOT NULL UNIQUE,
      created_at TEXT NOT NULL DEFAULT (datetime('now'))
    )
  `);
  db.exec(`
    CREATE TABLE IF NOT EXISTS users (
      id TEXT PRIMARY KEY,
      username TEXT NOT NULL UNIQUE,
      created_at TEXT NOT NULL DEFAULT (datetime('now'))
    )
  `);
  db.exec(`
    CREATE TABLE IF NOT EXISTS volume_access (
      volume_id TEXT NOT NULL REFERENCES volumes(id) ON DELETE CASCADE,
      user_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
      created_at TEXT NOT NULL DEFAULT (datetime('now')),
      PRIMARY KEY (volume_id, user_id)
    )
  `);
  db.exec(`
    CREATE TABLE IF NOT EXISTS invite_tokens (
      id TEXT PRIMARY KEY,
      created_by TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
      username TEXT NOT NULL,
      used_by TEXT REFERENCES users(id) ON DELETE SET NULL,
      used_at TEXT,
      expires_at TEXT NOT NULL,
      created_at TEXT NOT NULL DEFAULT (datetime('now'))
    )
  `);

  // Column migrations
  try { db.exec("ALTER TABLE users ADD COLUMN role TEXT NOT NULL DEFAULT 'user'"); } catch {}
  try { db.exec("ALTER TABLE volumes ADD COLUMN visibility TEXT NOT NULL DEFAULT 'public'"); } catch {}

  return db;
}

function nanoid(size = 21) {
  return crypto.randomBytes(size).toString("base64url").slice(0, size);
}

const [command, action, ...args] = process.argv.slice(2);

const readline = require("node:readline");

// Buffer stdin lines so prompts work with both piped and interactive input
const _stdinLines = [];
let _stdinDone = false;
let _stdinWaiter = null;

const _rl = readline.createInterface({ input: process.stdin, terminal: false });
_rl.on("line", (line) => {
  if (_stdinWaiter) {
    const resolve = _stdinWaiter;
    _stdinWaiter = null;
    resolve(line.trim());
  } else {
    _stdinLines.push(line.trim());
  }
});
_rl.on("close", () => {
  _stdinDone = true;
  if (_stdinWaiter) {
    const resolve = _stdinWaiter;
    _stdinWaiter = null;
    resolve("");
  }
});

function prompt(question) {
  process.stdout.write(question);
  if (_stdinLines.length > 0) {
    const answer = _stdinLines.shift();
    process.stdout.write(answer + "\n");
    return Promise.resolve(answer);
  }
  if (_stdinDone) return Promise.resolve("");
  return new Promise((resolve) => { _stdinWaiter = resolve; });
}

function discoverVolumes() {
  const volumesDir = "/Volumes";
  if (!fs.existsSync(volumesDir)) return [];
  return fs.readdirSync(volumesDir)
    .filter((name) => !name.startsWith("."))
    .map((name) => ({ name, path: path.join(volumesDir, name) }))
    .filter((v) => {
      try { fs.accessSync(v.path, fs.constants.R_OK); return true; } catch { return false; }
    });
}

const USAGE = `Usage:
  mininas volume list
  mininas volume add              (interactive)
  mininas volume add <id> <label> <path>
  mininas volume remove <id>
  mininas volume visibility <id> <public|private>
  mininas volume access list <volumeId>
  mininas volume access grant <volumeId> <userId>
  mininas volume access revoke <volumeId> <userId>

  mininas user list
  mininas user delete <id>

  mininas invite create <username> [--expires <hours>]
  mininas invite list
  mininas invite delete <id>`;

if (!command || (command !== "volume" && command !== "user" && command !== "invite")) {
  console.error(`Unknown command: ${command || "(none)"}`);
  console.error(USAGE);
  process.exit(1);
}

const db = getDb();

async function main() {

// --- Volume commands ---
if (command === "volume") {
  switch (action) {
    case "list": {
      const rows = db.prepare("SELECT id, label, path, visibility FROM volumes ORDER BY rowid").all();
      if (rows.length === 0) {
        console.log("No volumes configured.");
        console.log('Add one with: mininas volume add <id> <label> <path>');
      } else {
        const idW = Math.max(2, ...rows.map((r) => r.id.length));
        const labelW = Math.max(5, ...rows.map((r) => r.label.length));
        const visW = Math.max(10, ...rows.map((r) => r.visibility.length));
        console.log(
          `${"ID".padEnd(idW)}  ${"LABEL".padEnd(labelW)}  ${"VISIBILITY".padEnd(visW)}  PATH`
        );
        for (const r of rows) {
          console.log(
            `${r.id.padEnd(idW)}  ${r.label.padEnd(labelW)}  ${r.visibility.padEnd(visW)}  ${r.path}`
          );
        }
      }
      break;
    }

    case "add": {
      const [id, label, volumePath] = args;

      // Interactive mode when no arguments provided
      if (!id) {
        const registered = db.prepare("SELECT path FROM volumes").all().map((r) => r.path);
        const available = discoverVolumes().filter((v) => !registered.includes(v.path));

        if (available.length === 0) {
          console.log("No unregistered volumes found in /Volumes/.");
          console.log("You can add one manually: mininas volume add <id> <label> <path>");
          process.exit(0);
        }

        console.log("\nAvailable volumes:\n");
        for (let i = 0; i < available.length; i++) {
          console.log(`  ${i + 1}) ${available[i].name}  (${available[i].path})`);
        }
        console.log();

        const choice = await prompt(`Select a volume (1-${available.length}): `);
        const idx = parseInt(choice, 10) - 1;
        if (isNaN(idx) || idx < 0 || idx >= available.length) {
          console.error("Invalid selection.");
          process.exit(1);
        }

        const selected = available[idx];
        const defaultId = selected.name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
        const chosenId = (await prompt(`Volume ID [${defaultId}]: `)) || defaultId;
        const chosenLabel = (await prompt(`Label [${selected.name}]: `)) || selected.name;

        try {
          db.prepare("INSERT INTO volumes (id, label, path) VALUES (?, ?, ?)").run(
            chosenId,
            chosenLabel,
            selected.path
          );
          console.log(`\nAdded volume: ${chosenId} (${chosenLabel}) -> ${selected.path}`);
          console.log("Restart the server to pick up changes.");
        } catch (err) {
          if (err.code === "SQLITE_CONSTRAINT_PRIMARYKEY") {
            console.error(`Volume with id '${chosenId}' already exists.`);
          } else if (err.code === "SQLITE_CONSTRAINT_UNIQUE") {
            console.error(`A volume with path '${selected.path}' already exists.`);
          } else {
            console.error(`Error: ${err.message}`);
          }
          process.exit(1);
        }
        break;
      }

      // Explicit mode: mininas volume add <id> <label> <path>
      if (!label || !volumePath) {
        console.error("Usage: mininas volume add <id> <label> <path>");
        process.exit(1);
      }
      const resolved = path.resolve(volumePath);
      if (!fs.existsSync(resolved)) {
        console.error(`Path does not exist: ${resolved}`);
        process.exit(1);
      }
      try {
        db.prepare("INSERT INTO volumes (id, label, path) VALUES (?, ?, ?)").run(
          id,
          label,
          resolved
        );
        console.log(`Added volume: ${id} (${label}) -> ${resolved}`);
        console.log("Restart the server to pick up changes.");
      } catch (err) {
        if (err.code === "SQLITE_CONSTRAINT_PRIMARYKEY") {
          console.error(`Volume with id '${id}' already exists.`);
        } else if (err.code === "SQLITE_CONSTRAINT_UNIQUE") {
          console.error(`A volume with path '${resolved}' already exists.`);
        } else {
          console.error(`Error: ${err.message}`);
        }
        process.exit(1);
      }
      break;
    }

    case "remove": {
      const [removeId] = args;
      if (!removeId) {
        console.error("Usage: mininas volume remove <id>");
        process.exit(1);
      }
      const existing = db.prepare("SELECT id, label, path FROM volumes WHERE id = ?").get(removeId);
      if (!existing) {
        console.error(`Volume '${removeId}' not found.`);
        process.exit(1);
      }
      db.prepare("DELETE FROM volumes WHERE id = ?").run(removeId);
      console.log(`Removed volume: ${existing.id} (${existing.label}) -> ${existing.path}`);
      console.log("Restart the server to pick up changes.");
      break;
    }

    case "visibility": {
      const [volId, visibility] = args;
      if (!volId || !visibility || (visibility !== "public" && visibility !== "private")) {
        console.error("Usage: mininas volume visibility <id> <public|private>");
        process.exit(1);
      }
      const vol = db.prepare("SELECT id FROM volumes WHERE id = ?").get(volId);
      if (!vol) {
        console.error(`Volume '${volId}' not found.`);
        process.exit(1);
      }
      db.prepare("UPDATE volumes SET visibility = ? WHERE id = ?").run(visibility, volId);
      console.log(`Volume '${volId}' visibility set to '${visibility}'.`);
      break;
    }

    case "access": {
      const [accessAction, ...accessArgs] = args;

      switch (accessAction) {
        case "list": {
          const [volId] = accessArgs;
          if (!volId) {
            console.error("Usage: mininas volume access list <volumeId>");
            process.exit(1);
          }
          const vol = db.prepare("SELECT id FROM volumes WHERE id = ?").get(volId);
          if (!vol) {
            console.error(`Volume '${volId}' not found.`);
            process.exit(1);
          }
          const rows = db.prepare(
            `SELECT u.id, u.username, u.role FROM volume_access va
             JOIN users u ON u.id = va.user_id WHERE va.volume_id = ?
             ORDER BY u.username`
          ).all(volId);
          if (rows.length === 0) {
            console.log(`No explicit access grants for volume '${volId}'.`);
          } else {
            const idW = Math.max(2, ...rows.map((r) => r.id.length));
            const nameW = Math.max(8, ...rows.map((r) => r.username.length));
            console.log(`${"ID".padEnd(idW)}  ${"USERNAME".padEnd(nameW)}  ROLE`);
            for (const r of rows) {
              console.log(`${r.id.padEnd(idW)}  ${r.username.padEnd(nameW)}  ${r.role}`);
            }
          }
          break;
        }

        case "grant": {
          const [volId, userId] = accessArgs;
          if (!volId || !userId) {
            console.error("Usage: mininas volume access grant <volumeId> <userId>");
            process.exit(1);
          }
          const vol = db.prepare("SELECT id FROM volumes WHERE id = ?").get(volId);
          if (!vol) { console.error(`Volume '${volId}' not found.`); process.exit(1); }
          const user = db.prepare("SELECT id FROM users WHERE id = ?").get(userId);
          if (!user) { console.error(`User '${userId}' not found.`); process.exit(1); }
          db.prepare("INSERT OR IGNORE INTO volume_access (volume_id, user_id) VALUES (?, ?)").run(volId, userId);
          console.log(`Granted access to volume '${volId}' for user '${userId}'.`);
          break;
        }

        case "revoke": {
          const [volId, userId] = accessArgs;
          if (!volId || !userId) {
            console.error("Usage: mininas volume access revoke <volumeId> <userId>");
            process.exit(1);
          }
          db.prepare("DELETE FROM volume_access WHERE volume_id = ? AND user_id = ?").run(volId, userId);
          console.log(`Revoked access to volume '${volId}' for user '${userId}'.`);
          break;
        }

        default:
          console.error(`Unknown access action: ${accessAction || "(none)"}`);
          console.error("Usage: mininas volume access <list|grant|revoke>");
          process.exit(1);
      }
      break;
    }

    default:
      console.error(`Unknown action: ${action || "(none)"}`);
      console.error("Usage: mininas volume <list|add|remove|visibility|access>");
      process.exit(1);
  }
}

// --- User commands ---
if (command === "user") {
  switch (action) {
    case "list": {
      const rows = db.prepare("SELECT id, username, role, created_at FROM users ORDER BY created_at").all();
      if (rows.length === 0) {
        console.log("No users registered.");
      } else {
        const idW = Math.max(2, ...rows.map((r) => r.id.length));
        const nameW = Math.max(8, ...rows.map((r) => r.username.length));
        const roleW = Math.max(4, ...rows.map((r) => r.role.length));
        console.log(`${"ID".padEnd(idW)}  ${"USERNAME".padEnd(nameW)}  ${"ROLE".padEnd(roleW)}  CREATED`);
        for (const r of rows) {
          console.log(`${r.id.padEnd(idW)}  ${r.username.padEnd(nameW)}  ${r.role.padEnd(roleW)}  ${r.created_at}`);
        }
      }
      break;
    }

    case "delete": {
      const [userId] = args;
      if (!userId) {
        console.error("Usage: mininas user delete <id>");
        process.exit(1);
      }
      const user = db.prepare("SELECT id, username, role FROM users WHERE id = ?").get(userId);
      if (!user) {
        console.error(`User '${userId}' not found.`);
        process.exit(1);
      }
      if (user.role === "admin") {
        console.error("Cannot delete admin user.");
        process.exit(1);
      }
      db.prepare("DELETE FROM users WHERE id = ?").run(userId);
      console.log(`Deleted user: ${user.username} (${user.id})`);
      break;
    }

    default:
      console.error(`Unknown action: ${action || "(none)"}`);
      console.error("Usage: mininas user <list|delete>");
      process.exit(1);
  }
}

// --- Invite commands ---
if (command === "invite") {
  switch (action) {
    case "create": {
      const [username] = args;
      if (!username) {
        console.error("Usage: mininas invite create <username> [--expires <hours>]");
        process.exit(1);
      }
      let expiresInHours = 72;
      const expiresIdx = args.indexOf("--expires");
      if (expiresIdx !== -1 && args[expiresIdx + 1]) {
        expiresInHours = parseInt(args[expiresIdx + 1], 10);
        if (isNaN(expiresInHours) || expiresInHours <= 0) {
          console.error("--expires must be a positive number of hours.");
          process.exit(1);
        }
      }

      // Find admin user to set as creator
      const admin = db.prepare("SELECT id FROM users WHERE role = 'admin' LIMIT 1").get();
      if (!admin) {
        console.error("No admin user found. Run setup first.");
        process.exit(1);
      }

      const id = nanoid();
      const expiresAt = new Date(Date.now() + expiresInHours * 60 * 60 * 1000).toISOString();
      db.prepare(
        "INSERT INTO invite_tokens (id, created_by, username, expires_at) VALUES (?, ?, ?, ?)"
      ).run(id, admin.id, username, expiresAt);

      console.log(`Invite created for '${username}':`);
      console.log(`  Token: ${id}`);
      console.log(`  Expires: ${expiresAt}`);
      break;
    }

    case "list": {
      const rows = db.prepare(
        "SELECT id, username, used_by, used_at, expires_at, created_at FROM invite_tokens ORDER BY created_at DESC"
      ).all();
      if (rows.length === 0) {
        console.log("No invites.");
      } else {
        const idW = Math.max(5, ...rows.map((r) => r.id.length));
        const nameW = Math.max(8, ...rows.map((r) => r.username.length));
        console.log(`${"TOKEN".padEnd(idW)}  ${"USERNAME".padEnd(nameW)}  STATUS       EXPIRES`);
        for (const r of rows) {
          const status = r.used_by ? "used" : new Date(r.expires_at) < new Date() ? "expired" : "pending";
          console.log(`${r.id.padEnd(idW)}  ${r.username.padEnd(nameW)}  ${status.padEnd(11)}  ${r.expires_at}`);
        }
      }
      break;
    }

    case "delete": {
      const [inviteId] = args;
      if (!inviteId) {
        console.error("Usage: mininas invite delete <id>");
        process.exit(1);
      }
      const result = db.prepare("DELETE FROM invite_tokens WHERE id = ?").run(inviteId);
      if (result.changes === 0) {
        console.error(`Invite '${inviteId}' not found.`);
        process.exit(1);
      }
      console.log(`Deleted invite: ${inviteId}`);
      break;
    }

    default:
      console.error(`Unknown action: ${action || "(none)"}`);
      console.error("Usage: mininas invite <create|list|delete>");
      process.exit(1);
  }
}

} // end main

main().finally(() => { _rl.close(); db.close(); });
