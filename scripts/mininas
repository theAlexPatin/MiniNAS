#!/usr/bin/env node

const path = require("node:path");
const fs = require("node:fs");
const crypto = require("node:crypto");

// Load .env from monorepo root
const envPath = path.resolve(__dirname, "../.env");
if (fs.existsSync(envPath)) {
  for (const line of fs.readFileSync(envPath, "utf-8").split("\n")) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith("#")) continue;
    const eq = trimmed.indexOf("=");
    if (eq === -1) continue;
    const key = trimmed.slice(0, eq);
    const value = trimmed.slice(eq + 1);
    if (!(key in process.env)) process.env[key] = value;
  }
}

const { createRequire } = require("node:module");
const apiRequire = createRequire(
  path.resolve(__dirname, "../packages/api/package.json")
);
const Database = apiRequire("better-sqlite3");

const dbPath = path.resolve(
  __dirname,
  "..",
  process.env.DB_PATH || "./data/mininas.db"
);

function getDb() {
  const dbDir = path.dirname(dbPath);
  fs.mkdirSync(dbDir, { recursive: true });
  const db = new Database(dbPath);
  db.pragma("journal_mode = WAL");
  db.pragma("foreign_keys = ON");
  db.exec(`
    CREATE TABLE IF NOT EXISTS volumes (
      id TEXT PRIMARY KEY,
      label TEXT NOT NULL,
      path TEXT NOT NULL UNIQUE,
      created_at TEXT NOT NULL DEFAULT (datetime('now'))
    )
  `);
  db.exec(`
    CREATE TABLE IF NOT EXISTS users (
      id TEXT PRIMARY KEY,
      username TEXT NOT NULL UNIQUE,
      created_at TEXT NOT NULL DEFAULT (datetime('now'))
    )
  `);
  db.exec(`
    CREATE TABLE IF NOT EXISTS volume_access (
      volume_id TEXT NOT NULL REFERENCES volumes(id) ON DELETE CASCADE,
      user_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
      created_at TEXT NOT NULL DEFAULT (datetime('now')),
      PRIMARY KEY (volume_id, user_id)
    )
  `);
  db.exec(`
    CREATE TABLE IF NOT EXISTS invite_tokens (
      id TEXT PRIMARY KEY,
      created_by TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
      username TEXT NOT NULL,
      used_by TEXT REFERENCES users(id) ON DELETE SET NULL,
      used_at TEXT,
      expires_at TEXT NOT NULL,
      created_at TEXT NOT NULL DEFAULT (datetime('now'))
    )
  `);

  // Column migrations
  try { db.exec("ALTER TABLE users ADD COLUMN role TEXT NOT NULL DEFAULT 'user'"); } catch {}
  try { db.exec("ALTER TABLE volumes ADD COLUMN visibility TEXT NOT NULL DEFAULT 'public'"); } catch {}

  return db;
}

function nanoid(size = 21) {
  return crypto.randomBytes(size).toString("base64url").slice(0, size);
}

const [command, action, ...args] = process.argv.slice(2);

const USAGE = `Usage:
  mininas volume list
  mininas volume add <id> <label> <path>
  mininas volume remove <id>
  mininas volume visibility <id> <public|private>
  mininas volume access list <volumeId>
  mininas volume access grant <volumeId> <userId>
  mininas volume access revoke <volumeId> <userId>

  mininas user list
  mininas user delete <id>

  mininas invite create <username> [--expires <hours>]
  mininas invite list
  mininas invite delete <id>`;

if (!command || (command !== "volume" && command !== "user" && command !== "invite")) {
  console.error(`Unknown command: ${command || "(none)"}`);
  console.error(USAGE);
  process.exit(1);
}

const db = getDb();

// --- Volume commands ---
if (command === "volume") {
  switch (action) {
    case "list": {
      const rows = db.prepare("SELECT id, label, path, visibility FROM volumes ORDER BY rowid").all();
      if (rows.length === 0) {
        console.log("No volumes configured.");
        console.log('Add one with: mininas volume add <id> <label> <path>');
      } else {
        const idW = Math.max(2, ...rows.map((r) => r.id.length));
        const labelW = Math.max(5, ...rows.map((r) => r.label.length));
        const visW = Math.max(10, ...rows.map((r) => r.visibility.length));
        console.log(
          `${"ID".padEnd(idW)}  ${"LABEL".padEnd(labelW)}  ${"VISIBILITY".padEnd(visW)}  PATH`
        );
        for (const r of rows) {
          console.log(
            `${r.id.padEnd(idW)}  ${r.label.padEnd(labelW)}  ${r.visibility.padEnd(visW)}  ${r.path}`
          );
        }
      }
      break;
    }

    case "add": {
      const [id, label, volumePath] = args;
      if (!id || !label || !volumePath) {
        console.error("Usage: mininas volume add <id> <label> <path>");
        process.exit(1);
      }
      const resolved = path.resolve(volumePath);
      if (!fs.existsSync(resolved)) {
        console.error(`Path does not exist: ${resolved}`);
        process.exit(1);
      }
      try {
        db.prepare("INSERT INTO volumes (id, label, path) VALUES (?, ?, ?)").run(
          id,
          label,
          resolved
        );
        console.log(`Added volume: ${id} (${label}) -> ${resolved}`);
        console.log("Restart the server to pick up changes.");
      } catch (err) {
        if (err.code === "SQLITE_CONSTRAINT_PRIMARYKEY") {
          console.error(`Volume with id '${id}' already exists.`);
        } else if (err.code === "SQLITE_CONSTRAINT_UNIQUE") {
          console.error(`A volume with path '${resolved}' already exists.`);
        } else {
          console.error(`Error: ${err.message}`);
        }
        process.exit(1);
      }
      break;
    }

    case "remove": {
      const [removeId] = args;
      if (!removeId) {
        console.error("Usage: mininas volume remove <id>");
        process.exit(1);
      }
      const existing = db.prepare("SELECT id, label, path FROM volumes WHERE id = ?").get(removeId);
      if (!existing) {
        console.error(`Volume '${removeId}' not found.`);
        process.exit(1);
      }
      db.prepare("DELETE FROM volumes WHERE id = ?").run(removeId);
      console.log(`Removed volume: ${existing.id} (${existing.label}) -> ${existing.path}`);
      console.log("Restart the server to pick up changes.");
      break;
    }

    case "visibility": {
      const [volId, visibility] = args;
      if (!volId || !visibility || (visibility !== "public" && visibility !== "private")) {
        console.error("Usage: mininas volume visibility <id> <public|private>");
        process.exit(1);
      }
      const vol = db.prepare("SELECT id FROM volumes WHERE id = ?").get(volId);
      if (!vol) {
        console.error(`Volume '${volId}' not found.`);
        process.exit(1);
      }
      db.prepare("UPDATE volumes SET visibility = ? WHERE id = ?").run(visibility, volId);
      console.log(`Volume '${volId}' visibility set to '${visibility}'.`);
      break;
    }

    case "access": {
      const [accessAction, ...accessArgs] = args;

      switch (accessAction) {
        case "list": {
          const [volId] = accessArgs;
          if (!volId) {
            console.error("Usage: mininas volume access list <volumeId>");
            process.exit(1);
          }
          const vol = db.prepare("SELECT id FROM volumes WHERE id = ?").get(volId);
          if (!vol) {
            console.error(`Volume '${volId}' not found.`);
            process.exit(1);
          }
          const rows = db.prepare(
            `SELECT u.id, u.username, u.role FROM volume_access va
             JOIN users u ON u.id = va.user_id WHERE va.volume_id = ?
             ORDER BY u.username`
          ).all(volId);
          if (rows.length === 0) {
            console.log(`No explicit access grants for volume '${volId}'.`);
          } else {
            const idW = Math.max(2, ...rows.map((r) => r.id.length));
            const nameW = Math.max(8, ...rows.map((r) => r.username.length));
            console.log(`${"ID".padEnd(idW)}  ${"USERNAME".padEnd(nameW)}  ROLE`);
            for (const r of rows) {
              console.log(`${r.id.padEnd(idW)}  ${r.username.padEnd(nameW)}  ${r.role}`);
            }
          }
          break;
        }

        case "grant": {
          const [volId, userId] = accessArgs;
          if (!volId || !userId) {
            console.error("Usage: mininas volume access grant <volumeId> <userId>");
            process.exit(1);
          }
          const vol = db.prepare("SELECT id FROM volumes WHERE id = ?").get(volId);
          if (!vol) { console.error(`Volume '${volId}' not found.`); process.exit(1); }
          const user = db.prepare("SELECT id FROM users WHERE id = ?").get(userId);
          if (!user) { console.error(`User '${userId}' not found.`); process.exit(1); }
          db.prepare("INSERT OR IGNORE INTO volume_access (volume_id, user_id) VALUES (?, ?)").run(volId, userId);
          console.log(`Granted access to volume '${volId}' for user '${userId}'.`);
          break;
        }

        case "revoke": {
          const [volId, userId] = accessArgs;
          if (!volId || !userId) {
            console.error("Usage: mininas volume access revoke <volumeId> <userId>");
            process.exit(1);
          }
          db.prepare("DELETE FROM volume_access WHERE volume_id = ? AND user_id = ?").run(volId, userId);
          console.log(`Revoked access to volume '${volId}' for user '${userId}'.`);
          break;
        }

        default:
          console.error(`Unknown access action: ${accessAction || "(none)"}`);
          console.error("Usage: mininas volume access <list|grant|revoke>");
          process.exit(1);
      }
      break;
    }

    default:
      console.error(`Unknown action: ${action || "(none)"}`);
      console.error("Usage: mininas volume <list|add|remove|visibility|access>");
      process.exit(1);
  }
}

// --- User commands ---
if (command === "user") {
  switch (action) {
    case "list": {
      const rows = db.prepare("SELECT id, username, role, created_at FROM users ORDER BY created_at").all();
      if (rows.length === 0) {
        console.log("No users registered.");
      } else {
        const idW = Math.max(2, ...rows.map((r) => r.id.length));
        const nameW = Math.max(8, ...rows.map((r) => r.username.length));
        const roleW = Math.max(4, ...rows.map((r) => r.role.length));
        console.log(`${"ID".padEnd(idW)}  ${"USERNAME".padEnd(nameW)}  ${"ROLE".padEnd(roleW)}  CREATED`);
        for (const r of rows) {
          console.log(`${r.id.padEnd(idW)}  ${r.username.padEnd(nameW)}  ${r.role.padEnd(roleW)}  ${r.created_at}`);
        }
      }
      break;
    }

    case "delete": {
      const [userId] = args;
      if (!userId) {
        console.error("Usage: mininas user delete <id>");
        process.exit(1);
      }
      const user = db.prepare("SELECT id, username, role FROM users WHERE id = ?").get(userId);
      if (!user) {
        console.error(`User '${userId}' not found.`);
        process.exit(1);
      }
      if (user.role === "admin") {
        console.error("Cannot delete admin user.");
        process.exit(1);
      }
      db.prepare("DELETE FROM users WHERE id = ?").run(userId);
      console.log(`Deleted user: ${user.username} (${user.id})`);
      break;
    }

    default:
      console.error(`Unknown action: ${action || "(none)"}`);
      console.error("Usage: mininas user <list|delete>");
      process.exit(1);
  }
}

// --- Invite commands ---
if (command === "invite") {
  switch (action) {
    case "create": {
      const [username] = args;
      if (!username) {
        console.error("Usage: mininas invite create <username> [--expires <hours>]");
        process.exit(1);
      }
      let expiresInHours = 72;
      const expiresIdx = args.indexOf("--expires");
      if (expiresIdx !== -1 && args[expiresIdx + 1]) {
        expiresInHours = parseInt(args[expiresIdx + 1], 10);
        if (isNaN(expiresInHours) || expiresInHours <= 0) {
          console.error("--expires must be a positive number of hours.");
          process.exit(1);
        }
      }

      // Find admin user to set as creator
      const admin = db.prepare("SELECT id FROM users WHERE role = 'admin' LIMIT 1").get();
      if (!admin) {
        console.error("No admin user found. Run setup first.");
        process.exit(1);
      }

      const id = nanoid();
      const expiresAt = new Date(Date.now() + expiresInHours * 60 * 60 * 1000).toISOString();
      db.prepare(
        "INSERT INTO invite_tokens (id, created_by, username, expires_at) VALUES (?, ?, ?, ?)"
      ).run(id, admin.id, username, expiresAt);

      console.log(`Invite created for '${username}':`);
      console.log(`  Token: ${id}`);
      console.log(`  Expires: ${expiresAt}`);
      break;
    }

    case "list": {
      const rows = db.prepare(
        "SELECT id, username, used_by, used_at, expires_at, created_at FROM invite_tokens ORDER BY created_at DESC"
      ).all();
      if (rows.length === 0) {
        console.log("No invites.");
      } else {
        const idW = Math.max(5, ...rows.map((r) => r.id.length));
        const nameW = Math.max(8, ...rows.map((r) => r.username.length));
        console.log(`${"TOKEN".padEnd(idW)}  ${"USERNAME".padEnd(nameW)}  STATUS       EXPIRES`);
        for (const r of rows) {
          const status = r.used_by ? "used" : new Date(r.expires_at) < new Date() ? "expired" : "pending";
          console.log(`${r.id.padEnd(idW)}  ${r.username.padEnd(nameW)}  ${status.padEnd(11)}  ${r.expires_at}`);
        }
      }
      break;
    }

    case "delete": {
      const [inviteId] = args;
      if (!inviteId) {
        console.error("Usage: mininas invite delete <id>");
        process.exit(1);
      }
      const result = db.prepare("DELETE FROM invite_tokens WHERE id = ?").run(inviteId);
      if (result.changes === 0) {
        console.error(`Invite '${inviteId}' not found.`);
        process.exit(1);
      }
      console.log(`Deleted invite: ${inviteId}`);
      break;
    }

    default:
      console.error(`Unknown action: ${action || "(none)"}`);
      console.error("Usage: mininas invite <create|list|delete>");
      process.exit(1);
  }
}

db.close();
